// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: Session.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_Session_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_Session_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3012000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3012004 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
#include "Stream.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_Session_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_Session_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxillaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[8]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_Session_2eproto;
namespace ServerPushInterface {
class Session;
class SessionDefaultTypeInternal;
extern SessionDefaultTypeInternal _Session_default_instance_;
class SessionAllowDatagrams;
class SessionAllowDatagramsDefaultTypeInternal;
extern SessionAllowDatagramsDefaultTypeInternal _SessionAllowDatagrams_default_instance_;
class SessionChangeProperty;
class SessionChangePropertyDefaultTypeInternal;
extern SessionChangePropertyDefaultTypeInternal _SessionChangeProperty_default_instance_;
class SessionDisallowDatagrams;
class SessionDisallowDatagramsDefaultTypeInternal;
extern SessionDisallowDatagramsDefaultTypeInternal _SessionDisallowDatagrams_default_instance_;
class SessionFinishStream;
class SessionFinishStreamDefaultTypeInternal;
extern SessionFinishStreamDefaultTypeInternal _SessionFinishStream_default_instance_;
class SessionMakeStream;
class SessionMakeStreamDefaultTypeInternal;
extern SessionMakeStreamDefaultTypeInternal _SessionMakeStream_default_instance_;
class SessionMakeStream_Response;
class SessionMakeStream_ResponseDefaultTypeInternal;
extern SessionMakeStream_ResponseDefaultTypeInternal _SessionMakeStream_Response_default_instance_;
class Session_Response;
class Session_ResponseDefaultTypeInternal;
extern Session_ResponseDefaultTypeInternal _Session_Response_default_instance_;
}  // namespace ServerPushInterface
PROTOBUF_NAMESPACE_OPEN
template<> ::ServerPushInterface::Session* Arena::CreateMaybeMessage<::ServerPushInterface::Session>(Arena*);
template<> ::ServerPushInterface::SessionAllowDatagrams* Arena::CreateMaybeMessage<::ServerPushInterface::SessionAllowDatagrams>(Arena*);
template<> ::ServerPushInterface::SessionChangeProperty* Arena::CreateMaybeMessage<::ServerPushInterface::SessionChangeProperty>(Arena*);
template<> ::ServerPushInterface::SessionDisallowDatagrams* Arena::CreateMaybeMessage<::ServerPushInterface::SessionDisallowDatagrams>(Arena*);
template<> ::ServerPushInterface::SessionFinishStream* Arena::CreateMaybeMessage<::ServerPushInterface::SessionFinishStream>(Arena*);
template<> ::ServerPushInterface::SessionMakeStream* Arena::CreateMaybeMessage<::ServerPushInterface::SessionMakeStream>(Arena*);
template<> ::ServerPushInterface::SessionMakeStream_Response* Arena::CreateMaybeMessage<::ServerPushInterface::SessionMakeStream_Response>(Arena*);
template<> ::ServerPushInterface::Session_Response* Arena::CreateMaybeMessage<::ServerPushInterface::Session_Response>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace ServerPushInterface {

// ===================================================================

class Session_Response PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ServerPushInterface.Session.Response) */ {
 public:
  inline Session_Response() : Session_Response(nullptr) {};
  virtual ~Session_Response();

  Session_Response(const Session_Response& from);
  Session_Response(Session_Response&& from) noexcept
    : Session_Response() {
    *this = ::std::move(from);
  }

  inline Session_Response& operator=(const Session_Response& from) {
    CopyFrom(from);
    return *this;
  }
  inline Session_Response& operator=(Session_Response&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Session_Response& default_instance();

  enum CommandResponseCase {
    kStream = 1,
    kMakeSession = 2,
    COMMANDRESPONSE_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Session_Response* internal_default_instance() {
    return reinterpret_cast<const Session_Response*>(
               &_Session_Response_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(Session_Response& a, Session_Response& b) {
    a.Swap(&b);
  }
  inline void Swap(Session_Response* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Session_Response* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Session_Response* New() const final {
    return CreateMaybeMessage<Session_Response>(nullptr);
  }

  Session_Response* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Session_Response>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Session_Response& from);
  void MergeFrom(const Session_Response& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Session_Response* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ServerPushInterface.Session.Response";
  }
  protected:
  explicit Session_Response(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_Session_2eproto);
    return ::descriptor_table_Session_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStreamFieldNumber = 1,
    kMakeSessionFieldNumber = 2,
  };
  // .ServerPushInterface.Stream.Response stream = 1;
  bool has_stream() const;
  private:
  bool _internal_has_stream() const;
  public:
  void clear_stream();
  const ::ServerPushInterface::Stream_Response& stream() const;
  ::ServerPushInterface::Stream_Response* release_stream();
  ::ServerPushInterface::Stream_Response* mutable_stream();
  void set_allocated_stream(::ServerPushInterface::Stream_Response* stream);
  private:
  const ::ServerPushInterface::Stream_Response& _internal_stream() const;
  ::ServerPushInterface::Stream_Response* _internal_mutable_stream();
  public:
  void unsafe_arena_set_allocated_stream(
      ::ServerPushInterface::Stream_Response* stream);
  ::ServerPushInterface::Stream_Response* unsafe_arena_release_stream();

  // .ServerPushInterface.SessionMakeStream.Response make_session = 2;
  bool has_make_session() const;
  private:
  bool _internal_has_make_session() const;
  public:
  void clear_make_session();
  const ::ServerPushInterface::SessionMakeStream_Response& make_session() const;
  ::ServerPushInterface::SessionMakeStream_Response* release_make_session();
  ::ServerPushInterface::SessionMakeStream_Response* mutable_make_session();
  void set_allocated_make_session(::ServerPushInterface::SessionMakeStream_Response* make_session);
  private:
  const ::ServerPushInterface::SessionMakeStream_Response& _internal_make_session() const;
  ::ServerPushInterface::SessionMakeStream_Response* _internal_mutable_make_session();
  public:
  void unsafe_arena_set_allocated_make_session(
      ::ServerPushInterface::SessionMakeStream_Response* make_session);
  ::ServerPushInterface::SessionMakeStream_Response* unsafe_arena_release_make_session();

  void clear_CommandResponse();
  CommandResponseCase CommandResponse_case() const;
  // @@protoc_insertion_point(class_scope:ServerPushInterface.Session.Response)
 private:
  class _Internal;
  void set_has_stream();
  void set_has_make_session();

  inline bool has_CommandResponse() const;
  inline void clear_has_CommandResponse();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  union CommandResponseUnion {
    CommandResponseUnion() {}
    ::ServerPushInterface::Stream_Response* stream_;
    ::ServerPushInterface::SessionMakeStream_Response* make_session_;
  } CommandResponse_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint32 _oneof_case_[1];

  friend struct ::TableStruct_Session_2eproto;
};
// -------------------------------------------------------------------

class Session PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ServerPushInterface.Session) */ {
 public:
  inline Session() : Session(nullptr) {};
  virtual ~Session();

  Session(const Session& from);
  Session(Session&& from) noexcept
    : Session() {
    *this = ::std::move(from);
  }

  inline Session& operator=(const Session& from) {
    CopyFrom(from);
    return *this;
  }
  inline Session& operator=(Session&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Session& default_instance();

  enum CommandCase {
    kStream = 2,
    kAllowDatagrams = 3,
    kDisallowDatagrams = 4,
    kMakeStream = 5,
    kFinishStream = 6,
    kChangeProperty = 7,
    COMMAND_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Session* internal_default_instance() {
    return reinterpret_cast<const Session*>(
               &_Session_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(Session& a, Session& b) {
    a.Swap(&b);
  }
  inline void Swap(Session* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Session* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Session* New() const final {
    return CreateMaybeMessage<Session>(nullptr);
  }

  Session* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Session>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Session& from);
  void MergeFrom(const Session& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Session* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ServerPushInterface.Session";
  }
  protected:
  explicit Session(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_Session_2eproto);
    return ::descriptor_table_Session_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef Session_Response Response;

  // accessors -------------------------------------------------------

  enum : int {
    kSessionIdFieldNumber = 1,
    kStreamFieldNumber = 2,
    kAllowDatagramsFieldNumber = 3,
    kDisallowDatagramsFieldNumber = 4,
    kMakeStreamFieldNumber = 5,
    kFinishStreamFieldNumber = 6,
    kChangePropertyFieldNumber = 7,
  };
  // uint32 session_id = 1;
  void clear_session_id();
  ::PROTOBUF_NAMESPACE_ID::uint32 session_id() const;
  void set_session_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_session_id() const;
  void _internal_set_session_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // .ServerPushInterface.Stream stream = 2;
  bool has_stream() const;
  private:
  bool _internal_has_stream() const;
  public:
  void clear_stream();
  const ::ServerPushInterface::Stream& stream() const;
  ::ServerPushInterface::Stream* release_stream();
  ::ServerPushInterface::Stream* mutable_stream();
  void set_allocated_stream(::ServerPushInterface::Stream* stream);
  private:
  const ::ServerPushInterface::Stream& _internal_stream() const;
  ::ServerPushInterface::Stream* _internal_mutable_stream();
  public:
  void unsafe_arena_set_allocated_stream(
      ::ServerPushInterface::Stream* stream);
  ::ServerPushInterface::Stream* unsafe_arena_release_stream();

  // .ServerPushInterface.SessionAllowDatagrams allow_datagrams = 3;
  bool has_allow_datagrams() const;
  private:
  bool _internal_has_allow_datagrams() const;
  public:
  void clear_allow_datagrams();
  const ::ServerPushInterface::SessionAllowDatagrams& allow_datagrams() const;
  ::ServerPushInterface::SessionAllowDatagrams* release_allow_datagrams();
  ::ServerPushInterface::SessionAllowDatagrams* mutable_allow_datagrams();
  void set_allocated_allow_datagrams(::ServerPushInterface::SessionAllowDatagrams* allow_datagrams);
  private:
  const ::ServerPushInterface::SessionAllowDatagrams& _internal_allow_datagrams() const;
  ::ServerPushInterface::SessionAllowDatagrams* _internal_mutable_allow_datagrams();
  public:
  void unsafe_arena_set_allocated_allow_datagrams(
      ::ServerPushInterface::SessionAllowDatagrams* allow_datagrams);
  ::ServerPushInterface::SessionAllowDatagrams* unsafe_arena_release_allow_datagrams();

  // .ServerPushInterface.SessionDisallowDatagrams disallow_datagrams = 4;
  bool has_disallow_datagrams() const;
  private:
  bool _internal_has_disallow_datagrams() const;
  public:
  void clear_disallow_datagrams();
  const ::ServerPushInterface::SessionDisallowDatagrams& disallow_datagrams() const;
  ::ServerPushInterface::SessionDisallowDatagrams* release_disallow_datagrams();
  ::ServerPushInterface::SessionDisallowDatagrams* mutable_disallow_datagrams();
  void set_allocated_disallow_datagrams(::ServerPushInterface::SessionDisallowDatagrams* disallow_datagrams);
  private:
  const ::ServerPushInterface::SessionDisallowDatagrams& _internal_disallow_datagrams() const;
  ::ServerPushInterface::SessionDisallowDatagrams* _internal_mutable_disallow_datagrams();
  public:
  void unsafe_arena_set_allocated_disallow_datagrams(
      ::ServerPushInterface::SessionDisallowDatagrams* disallow_datagrams);
  ::ServerPushInterface::SessionDisallowDatagrams* unsafe_arena_release_disallow_datagrams();

  // .ServerPushInterface.SessionMakeStream make_stream = 5;
  bool has_make_stream() const;
  private:
  bool _internal_has_make_stream() const;
  public:
  void clear_make_stream();
  const ::ServerPushInterface::SessionMakeStream& make_stream() const;
  ::ServerPushInterface::SessionMakeStream* release_make_stream();
  ::ServerPushInterface::SessionMakeStream* mutable_make_stream();
  void set_allocated_make_stream(::ServerPushInterface::SessionMakeStream* make_stream);
  private:
  const ::ServerPushInterface::SessionMakeStream& _internal_make_stream() const;
  ::ServerPushInterface::SessionMakeStream* _internal_mutable_make_stream();
  public:
  void unsafe_arena_set_allocated_make_stream(
      ::ServerPushInterface::SessionMakeStream* make_stream);
  ::ServerPushInterface::SessionMakeStream* unsafe_arena_release_make_stream();

  // .ServerPushInterface.SessionFinishStream finish_stream = 6;
  bool has_finish_stream() const;
  private:
  bool _internal_has_finish_stream() const;
  public:
  void clear_finish_stream();
  const ::ServerPushInterface::SessionFinishStream& finish_stream() const;
  ::ServerPushInterface::SessionFinishStream* release_finish_stream();
  ::ServerPushInterface::SessionFinishStream* mutable_finish_stream();
  void set_allocated_finish_stream(::ServerPushInterface::SessionFinishStream* finish_stream);
  private:
  const ::ServerPushInterface::SessionFinishStream& _internal_finish_stream() const;
  ::ServerPushInterface::SessionFinishStream* _internal_mutable_finish_stream();
  public:
  void unsafe_arena_set_allocated_finish_stream(
      ::ServerPushInterface::SessionFinishStream* finish_stream);
  ::ServerPushInterface::SessionFinishStream* unsafe_arena_release_finish_stream();

  // .ServerPushInterface.SessionChangeProperty change_property = 7;
  bool has_change_property() const;
  private:
  bool _internal_has_change_property() const;
  public:
  void clear_change_property();
  const ::ServerPushInterface::SessionChangeProperty& change_property() const;
  ::ServerPushInterface::SessionChangeProperty* release_change_property();
  ::ServerPushInterface::SessionChangeProperty* mutable_change_property();
  void set_allocated_change_property(::ServerPushInterface::SessionChangeProperty* change_property);
  private:
  const ::ServerPushInterface::SessionChangeProperty& _internal_change_property() const;
  ::ServerPushInterface::SessionChangeProperty* _internal_mutable_change_property();
  public:
  void unsafe_arena_set_allocated_change_property(
      ::ServerPushInterface::SessionChangeProperty* change_property);
  ::ServerPushInterface::SessionChangeProperty* unsafe_arena_release_change_property();

  void clear_Command();
  CommandCase Command_case() const;
  // @@protoc_insertion_point(class_scope:ServerPushInterface.Session)
 private:
  class _Internal;
  void set_has_stream();
  void set_has_allow_datagrams();
  void set_has_disallow_datagrams();
  void set_has_make_stream();
  void set_has_finish_stream();
  void set_has_change_property();

  inline bool has_Command() const;
  inline void clear_has_Command();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::uint32 session_id_;
  union CommandUnion {
    CommandUnion() {}
    ::ServerPushInterface::Stream* stream_;
    ::ServerPushInterface::SessionAllowDatagrams* allow_datagrams_;
    ::ServerPushInterface::SessionDisallowDatagrams* disallow_datagrams_;
    ::ServerPushInterface::SessionMakeStream* make_stream_;
    ::ServerPushInterface::SessionFinishStream* finish_stream_;
    ::ServerPushInterface::SessionChangeProperty* change_property_;
  } Command_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint32 _oneof_case_[1];

  friend struct ::TableStruct_Session_2eproto;
};
// -------------------------------------------------------------------

class SessionAllowDatagrams PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ServerPushInterface.SessionAllowDatagrams) */ {
 public:
  inline SessionAllowDatagrams() : SessionAllowDatagrams(nullptr) {};
  virtual ~SessionAllowDatagrams();

  SessionAllowDatagrams(const SessionAllowDatagrams& from);
  SessionAllowDatagrams(SessionAllowDatagrams&& from) noexcept
    : SessionAllowDatagrams() {
    *this = ::std::move(from);
  }

  inline SessionAllowDatagrams& operator=(const SessionAllowDatagrams& from) {
    CopyFrom(from);
    return *this;
  }
  inline SessionAllowDatagrams& operator=(SessionAllowDatagrams&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const SessionAllowDatagrams& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SessionAllowDatagrams* internal_default_instance() {
    return reinterpret_cast<const SessionAllowDatagrams*>(
               &_SessionAllowDatagrams_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(SessionAllowDatagrams& a, SessionAllowDatagrams& b) {
    a.Swap(&b);
  }
  inline void Swap(SessionAllowDatagrams* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SessionAllowDatagrams* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SessionAllowDatagrams* New() const final {
    return CreateMaybeMessage<SessionAllowDatagrams>(nullptr);
  }

  SessionAllowDatagrams* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SessionAllowDatagrams>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const SessionAllowDatagrams& from);
  void MergeFrom(const SessionAllowDatagrams& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SessionAllowDatagrams* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ServerPushInterface.SessionAllowDatagrams";
  }
  protected:
  explicit SessionAllowDatagrams(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_Session_2eproto);
    return ::descriptor_table_Session_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSizeFieldNumber = 1,
  };
  // uint32 size = 1;
  void clear_size();
  ::PROTOBUF_NAMESPACE_ID::uint32 size() const;
  void set_size(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_size() const;
  void _internal_set_size(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:ServerPushInterface.SessionAllowDatagrams)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::uint32 size_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Session_2eproto;
};
// -------------------------------------------------------------------

class SessionDisallowDatagrams PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ServerPushInterface.SessionDisallowDatagrams) */ {
 public:
  inline SessionDisallowDatagrams() : SessionDisallowDatagrams(nullptr) {};
  virtual ~SessionDisallowDatagrams();

  SessionDisallowDatagrams(const SessionDisallowDatagrams& from);
  SessionDisallowDatagrams(SessionDisallowDatagrams&& from) noexcept
    : SessionDisallowDatagrams() {
    *this = ::std::move(from);
  }

  inline SessionDisallowDatagrams& operator=(const SessionDisallowDatagrams& from) {
    CopyFrom(from);
    return *this;
  }
  inline SessionDisallowDatagrams& operator=(SessionDisallowDatagrams&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const SessionDisallowDatagrams& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SessionDisallowDatagrams* internal_default_instance() {
    return reinterpret_cast<const SessionDisallowDatagrams*>(
               &_SessionDisallowDatagrams_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(SessionDisallowDatagrams& a, SessionDisallowDatagrams& b) {
    a.Swap(&b);
  }
  inline void Swap(SessionDisallowDatagrams* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SessionDisallowDatagrams* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SessionDisallowDatagrams* New() const final {
    return CreateMaybeMessage<SessionDisallowDatagrams>(nullptr);
  }

  SessionDisallowDatagrams* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SessionDisallowDatagrams>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const SessionDisallowDatagrams& from);
  void MergeFrom(const SessionDisallowDatagrams& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SessionDisallowDatagrams* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ServerPushInterface.SessionDisallowDatagrams";
  }
  protected:
  explicit SessionDisallowDatagrams(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_Session_2eproto);
    return ::descriptor_table_Session_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:ServerPushInterface.SessionDisallowDatagrams)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Session_2eproto;
};
// -------------------------------------------------------------------

class SessionFinishStream PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ServerPushInterface.SessionFinishStream) */ {
 public:
  inline SessionFinishStream() : SessionFinishStream(nullptr) {};
  virtual ~SessionFinishStream();

  SessionFinishStream(const SessionFinishStream& from);
  SessionFinishStream(SessionFinishStream&& from) noexcept
    : SessionFinishStream() {
    *this = ::std::move(from);
  }

  inline SessionFinishStream& operator=(const SessionFinishStream& from) {
    CopyFrom(from);
    return *this;
  }
  inline SessionFinishStream& operator=(SessionFinishStream&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const SessionFinishStream& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SessionFinishStream* internal_default_instance() {
    return reinterpret_cast<const SessionFinishStream*>(
               &_SessionFinishStream_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(SessionFinishStream& a, SessionFinishStream& b) {
    a.Swap(&b);
  }
  inline void Swap(SessionFinishStream* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SessionFinishStream* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SessionFinishStream* New() const final {
    return CreateMaybeMessage<SessionFinishStream>(nullptr);
  }

  SessionFinishStream* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SessionFinishStream>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const SessionFinishStream& from);
  void MergeFrom(const SessionFinishStream& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SessionFinishStream* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ServerPushInterface.SessionFinishStream";
  }
  protected:
  explicit SessionFinishStream(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_Session_2eproto);
    return ::descriptor_table_Session_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStreamIdFieldNumber = 1,
  };
  // uint32 stream_id = 1;
  void clear_stream_id();
  ::PROTOBUF_NAMESPACE_ID::uint32 stream_id() const;
  void set_stream_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_stream_id() const;
  void _internal_set_stream_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:ServerPushInterface.SessionFinishStream)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::uint32 stream_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Session_2eproto;
};
// -------------------------------------------------------------------

class SessionMakeStream_Response PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ServerPushInterface.SessionMakeStream.Response) */ {
 public:
  inline SessionMakeStream_Response() : SessionMakeStream_Response(nullptr) {};
  virtual ~SessionMakeStream_Response();

  SessionMakeStream_Response(const SessionMakeStream_Response& from);
  SessionMakeStream_Response(SessionMakeStream_Response&& from) noexcept
    : SessionMakeStream_Response() {
    *this = ::std::move(from);
  }

  inline SessionMakeStream_Response& operator=(const SessionMakeStream_Response& from) {
    CopyFrom(from);
    return *this;
  }
  inline SessionMakeStream_Response& operator=(SessionMakeStream_Response&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const SessionMakeStream_Response& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SessionMakeStream_Response* internal_default_instance() {
    return reinterpret_cast<const SessionMakeStream_Response*>(
               &_SessionMakeStream_Response_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(SessionMakeStream_Response& a, SessionMakeStream_Response& b) {
    a.Swap(&b);
  }
  inline void Swap(SessionMakeStream_Response* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SessionMakeStream_Response* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SessionMakeStream_Response* New() const final {
    return CreateMaybeMessage<SessionMakeStream_Response>(nullptr);
  }

  SessionMakeStream_Response* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SessionMakeStream_Response>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const SessionMakeStream_Response& from);
  void MergeFrom(const SessionMakeStream_Response& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SessionMakeStream_Response* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ServerPushInterface.SessionMakeStream.Response";
  }
  protected:
  explicit SessionMakeStream_Response(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_Session_2eproto);
    return ::descriptor_table_Session_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStreamIdFieldNumber = 1,
  };
  // uint32 stream_id = 1;
  void clear_stream_id();
  ::PROTOBUF_NAMESPACE_ID::uint32 stream_id() const;
  void set_stream_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_stream_id() const;
  void _internal_set_stream_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:ServerPushInterface.SessionMakeStream.Response)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::uint32 stream_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Session_2eproto;
};
// -------------------------------------------------------------------

class SessionMakeStream PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ServerPushInterface.SessionMakeStream) */ {
 public:
  inline SessionMakeStream() : SessionMakeStream(nullptr) {};
  virtual ~SessionMakeStream();

  SessionMakeStream(const SessionMakeStream& from);
  SessionMakeStream(SessionMakeStream&& from) noexcept
    : SessionMakeStream() {
    *this = ::std::move(from);
  }

  inline SessionMakeStream& operator=(const SessionMakeStream& from) {
    CopyFrom(from);
    return *this;
  }
  inline SessionMakeStream& operator=(SessionMakeStream&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const SessionMakeStream& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SessionMakeStream* internal_default_instance() {
    return reinterpret_cast<const SessionMakeStream*>(
               &_SessionMakeStream_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(SessionMakeStream& a, SessionMakeStream& b) {
    a.Swap(&b);
  }
  inline void Swap(SessionMakeStream* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SessionMakeStream* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SessionMakeStream* New() const final {
    return CreateMaybeMessage<SessionMakeStream>(nullptr);
  }

  SessionMakeStream* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SessionMakeStream>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const SessionMakeStream& from);
  void MergeFrom(const SessionMakeStream& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SessionMakeStream* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ServerPushInterface.SessionMakeStream";
  }
  protected:
  explicit SessionMakeStream(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_Session_2eproto);
    return ::descriptor_table_Session_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef SessionMakeStream_Response Response;

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:ServerPushInterface.SessionMakeStream)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Session_2eproto;
};
// -------------------------------------------------------------------

class SessionChangeProperty PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ServerPushInterface.SessionChangeProperty) */ {
 public:
  inline SessionChangeProperty() : SessionChangeProperty(nullptr) {};
  virtual ~SessionChangeProperty();

  SessionChangeProperty(const SessionChangeProperty& from);
  SessionChangeProperty(SessionChangeProperty&& from) noexcept
    : SessionChangeProperty() {
    *this = ::std::move(from);
  }

  inline SessionChangeProperty& operator=(const SessionChangeProperty& from) {
    CopyFrom(from);
    return *this;
  }
  inline SessionChangeProperty& operator=(SessionChangeProperty&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const SessionChangeProperty& default_instance();

  enum PropertiesCase {
    kMaxRate = 1,
    kMaxIdle = 2,
    PROPERTIES_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SessionChangeProperty* internal_default_instance() {
    return reinterpret_cast<const SessionChangeProperty*>(
               &_SessionChangeProperty_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(SessionChangeProperty& a, SessionChangeProperty& b) {
    a.Swap(&b);
  }
  inline void Swap(SessionChangeProperty* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SessionChangeProperty* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SessionChangeProperty* New() const final {
    return CreateMaybeMessage<SessionChangeProperty>(nullptr);
  }

  SessionChangeProperty* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SessionChangeProperty>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const SessionChangeProperty& from);
  void MergeFrom(const SessionChangeProperty& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SessionChangeProperty* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ServerPushInterface.SessionChangeProperty";
  }
  protected:
  explicit SessionChangeProperty(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_Session_2eproto);
    return ::descriptor_table_Session_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMaxRateFieldNumber = 1,
    kMaxIdleFieldNumber = 2,
  };
  // uint32 max_rate = 1;
  private:
  bool _internal_has_max_rate() const;
  public:
  void clear_max_rate();
  ::PROTOBUF_NAMESPACE_ID::uint32 max_rate() const;
  void set_max_rate(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_max_rate() const;
  void _internal_set_max_rate(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // uint32 max_idle = 2;
  private:
  bool _internal_has_max_idle() const;
  public:
  void clear_max_idle();
  ::PROTOBUF_NAMESPACE_ID::uint32 max_idle() const;
  void set_max_idle(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_max_idle() const;
  void _internal_set_max_idle(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  void clear_Properties();
  PropertiesCase Properties_case() const;
  // @@protoc_insertion_point(class_scope:ServerPushInterface.SessionChangeProperty)
 private:
  class _Internal;
  void set_has_max_rate();
  void set_has_max_idle();

  inline bool has_Properties() const;
  inline void clear_has_Properties();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  union PropertiesUnion {
    PropertiesUnion() {}
    ::PROTOBUF_NAMESPACE_ID::uint32 max_rate_;
    ::PROTOBUF_NAMESPACE_ID::uint32 max_idle_;
  } Properties_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint32 _oneof_case_[1];

  friend struct ::TableStruct_Session_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Session_Response

// .ServerPushInterface.Stream.Response stream = 1;
inline bool Session_Response::_internal_has_stream() const {
  return CommandResponse_case() == kStream;
}
inline bool Session_Response::has_stream() const {
  return _internal_has_stream();
}
inline void Session_Response::set_has_stream() {
  _oneof_case_[0] = kStream;
}
inline ::ServerPushInterface::Stream_Response* Session_Response::release_stream() {
  // @@protoc_insertion_point(field_release:ServerPushInterface.Session.Response.stream)
  if (_internal_has_stream()) {
    clear_has_CommandResponse();
      ::ServerPushInterface::Stream_Response* temp = CommandResponse_.stream_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    CommandResponse_.stream_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ServerPushInterface::Stream_Response& Session_Response::_internal_stream() const {
  return _internal_has_stream()
      ? *CommandResponse_.stream_
      : *reinterpret_cast< ::ServerPushInterface::Stream_Response*>(&::ServerPushInterface::_Stream_Response_default_instance_);
}
inline const ::ServerPushInterface::Stream_Response& Session_Response::stream() const {
  // @@protoc_insertion_point(field_get:ServerPushInterface.Session.Response.stream)
  return _internal_stream();
}
inline ::ServerPushInterface::Stream_Response* Session_Response::unsafe_arena_release_stream() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ServerPushInterface.Session.Response.stream)
  if (_internal_has_stream()) {
    clear_has_CommandResponse();
    ::ServerPushInterface::Stream_Response* temp = CommandResponse_.stream_;
    CommandResponse_.stream_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Session_Response::unsafe_arena_set_allocated_stream(::ServerPushInterface::Stream_Response* stream) {
  clear_CommandResponse();
  if (stream) {
    set_has_stream();
    CommandResponse_.stream_ = stream;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ServerPushInterface.Session.Response.stream)
}
inline ::ServerPushInterface::Stream_Response* Session_Response::_internal_mutable_stream() {
  if (!_internal_has_stream()) {
    clear_CommandResponse();
    set_has_stream();
    CommandResponse_.stream_ = CreateMaybeMessage< ::ServerPushInterface::Stream_Response >(GetArena());
  }
  return CommandResponse_.stream_;
}
inline ::ServerPushInterface::Stream_Response* Session_Response::mutable_stream() {
  // @@protoc_insertion_point(field_mutable:ServerPushInterface.Session.Response.stream)
  return _internal_mutable_stream();
}

// .ServerPushInterface.SessionMakeStream.Response make_session = 2;
inline bool Session_Response::_internal_has_make_session() const {
  return CommandResponse_case() == kMakeSession;
}
inline bool Session_Response::has_make_session() const {
  return _internal_has_make_session();
}
inline void Session_Response::set_has_make_session() {
  _oneof_case_[0] = kMakeSession;
}
inline void Session_Response::clear_make_session() {
  if (_internal_has_make_session()) {
    if (GetArena() == nullptr) {
      delete CommandResponse_.make_session_;
    }
    clear_has_CommandResponse();
  }
}
inline ::ServerPushInterface::SessionMakeStream_Response* Session_Response::release_make_session() {
  // @@protoc_insertion_point(field_release:ServerPushInterface.Session.Response.make_session)
  if (_internal_has_make_session()) {
    clear_has_CommandResponse();
      ::ServerPushInterface::SessionMakeStream_Response* temp = CommandResponse_.make_session_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    CommandResponse_.make_session_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ServerPushInterface::SessionMakeStream_Response& Session_Response::_internal_make_session() const {
  return _internal_has_make_session()
      ? *CommandResponse_.make_session_
      : *reinterpret_cast< ::ServerPushInterface::SessionMakeStream_Response*>(&::ServerPushInterface::_SessionMakeStream_Response_default_instance_);
}
inline const ::ServerPushInterface::SessionMakeStream_Response& Session_Response::make_session() const {
  // @@protoc_insertion_point(field_get:ServerPushInterface.Session.Response.make_session)
  return _internal_make_session();
}
inline ::ServerPushInterface::SessionMakeStream_Response* Session_Response::unsafe_arena_release_make_session() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ServerPushInterface.Session.Response.make_session)
  if (_internal_has_make_session()) {
    clear_has_CommandResponse();
    ::ServerPushInterface::SessionMakeStream_Response* temp = CommandResponse_.make_session_;
    CommandResponse_.make_session_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Session_Response::unsafe_arena_set_allocated_make_session(::ServerPushInterface::SessionMakeStream_Response* make_session) {
  clear_CommandResponse();
  if (make_session) {
    set_has_make_session();
    CommandResponse_.make_session_ = make_session;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ServerPushInterface.Session.Response.make_session)
}
inline ::ServerPushInterface::SessionMakeStream_Response* Session_Response::_internal_mutable_make_session() {
  if (!_internal_has_make_session()) {
    clear_CommandResponse();
    set_has_make_session();
    CommandResponse_.make_session_ = CreateMaybeMessage< ::ServerPushInterface::SessionMakeStream_Response >(GetArena());
  }
  return CommandResponse_.make_session_;
}
inline ::ServerPushInterface::SessionMakeStream_Response* Session_Response::mutable_make_session() {
  // @@protoc_insertion_point(field_mutable:ServerPushInterface.Session.Response.make_session)
  return _internal_mutable_make_session();
}

inline bool Session_Response::has_CommandResponse() const {
  return CommandResponse_case() != COMMANDRESPONSE_NOT_SET;
}
inline void Session_Response::clear_has_CommandResponse() {
  _oneof_case_[0] = COMMANDRESPONSE_NOT_SET;
}
inline Session_Response::CommandResponseCase Session_Response::CommandResponse_case() const {
  return Session_Response::CommandResponseCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// Session

// uint32 session_id = 1;
inline void Session::clear_session_id() {
  session_id_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Session::_internal_session_id() const {
  return session_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Session::session_id() const {
  // @@protoc_insertion_point(field_get:ServerPushInterface.Session.session_id)
  return _internal_session_id();
}
inline void Session::_internal_set_session_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  session_id_ = value;
}
inline void Session::set_session_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_session_id(value);
  // @@protoc_insertion_point(field_set:ServerPushInterface.Session.session_id)
}

// .ServerPushInterface.Stream stream = 2;
inline bool Session::_internal_has_stream() const {
  return Command_case() == kStream;
}
inline bool Session::has_stream() const {
  return _internal_has_stream();
}
inline void Session::set_has_stream() {
  _oneof_case_[0] = kStream;
}
inline ::ServerPushInterface::Stream* Session::release_stream() {
  // @@protoc_insertion_point(field_release:ServerPushInterface.Session.stream)
  if (_internal_has_stream()) {
    clear_has_Command();
      ::ServerPushInterface::Stream* temp = Command_.stream_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    Command_.stream_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ServerPushInterface::Stream& Session::_internal_stream() const {
  return _internal_has_stream()
      ? *Command_.stream_
      : *reinterpret_cast< ::ServerPushInterface::Stream*>(&::ServerPushInterface::_Stream_default_instance_);
}
inline const ::ServerPushInterface::Stream& Session::stream() const {
  // @@protoc_insertion_point(field_get:ServerPushInterface.Session.stream)
  return _internal_stream();
}
inline ::ServerPushInterface::Stream* Session::unsafe_arena_release_stream() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ServerPushInterface.Session.stream)
  if (_internal_has_stream()) {
    clear_has_Command();
    ::ServerPushInterface::Stream* temp = Command_.stream_;
    Command_.stream_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Session::unsafe_arena_set_allocated_stream(::ServerPushInterface::Stream* stream) {
  clear_Command();
  if (stream) {
    set_has_stream();
    Command_.stream_ = stream;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ServerPushInterface.Session.stream)
}
inline ::ServerPushInterface::Stream* Session::_internal_mutable_stream() {
  if (!_internal_has_stream()) {
    clear_Command();
    set_has_stream();
    Command_.stream_ = CreateMaybeMessage< ::ServerPushInterface::Stream >(GetArena());
  }
  return Command_.stream_;
}
inline ::ServerPushInterface::Stream* Session::mutable_stream() {
  // @@protoc_insertion_point(field_mutable:ServerPushInterface.Session.stream)
  return _internal_mutable_stream();
}

// .ServerPushInterface.SessionAllowDatagrams allow_datagrams = 3;
inline bool Session::_internal_has_allow_datagrams() const {
  return Command_case() == kAllowDatagrams;
}
inline bool Session::has_allow_datagrams() const {
  return _internal_has_allow_datagrams();
}
inline void Session::set_has_allow_datagrams() {
  _oneof_case_[0] = kAllowDatagrams;
}
inline void Session::clear_allow_datagrams() {
  if (_internal_has_allow_datagrams()) {
    if (GetArena() == nullptr) {
      delete Command_.allow_datagrams_;
    }
    clear_has_Command();
  }
}
inline ::ServerPushInterface::SessionAllowDatagrams* Session::release_allow_datagrams() {
  // @@protoc_insertion_point(field_release:ServerPushInterface.Session.allow_datagrams)
  if (_internal_has_allow_datagrams()) {
    clear_has_Command();
      ::ServerPushInterface::SessionAllowDatagrams* temp = Command_.allow_datagrams_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    Command_.allow_datagrams_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ServerPushInterface::SessionAllowDatagrams& Session::_internal_allow_datagrams() const {
  return _internal_has_allow_datagrams()
      ? *Command_.allow_datagrams_
      : *reinterpret_cast< ::ServerPushInterface::SessionAllowDatagrams*>(&::ServerPushInterface::_SessionAllowDatagrams_default_instance_);
}
inline const ::ServerPushInterface::SessionAllowDatagrams& Session::allow_datagrams() const {
  // @@protoc_insertion_point(field_get:ServerPushInterface.Session.allow_datagrams)
  return _internal_allow_datagrams();
}
inline ::ServerPushInterface::SessionAllowDatagrams* Session::unsafe_arena_release_allow_datagrams() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ServerPushInterface.Session.allow_datagrams)
  if (_internal_has_allow_datagrams()) {
    clear_has_Command();
    ::ServerPushInterface::SessionAllowDatagrams* temp = Command_.allow_datagrams_;
    Command_.allow_datagrams_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Session::unsafe_arena_set_allocated_allow_datagrams(::ServerPushInterface::SessionAllowDatagrams* allow_datagrams) {
  clear_Command();
  if (allow_datagrams) {
    set_has_allow_datagrams();
    Command_.allow_datagrams_ = allow_datagrams;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ServerPushInterface.Session.allow_datagrams)
}
inline ::ServerPushInterface::SessionAllowDatagrams* Session::_internal_mutable_allow_datagrams() {
  if (!_internal_has_allow_datagrams()) {
    clear_Command();
    set_has_allow_datagrams();
    Command_.allow_datagrams_ = CreateMaybeMessage< ::ServerPushInterface::SessionAllowDatagrams >(GetArena());
  }
  return Command_.allow_datagrams_;
}
inline ::ServerPushInterface::SessionAllowDatagrams* Session::mutable_allow_datagrams() {
  // @@protoc_insertion_point(field_mutable:ServerPushInterface.Session.allow_datagrams)
  return _internal_mutable_allow_datagrams();
}

// .ServerPushInterface.SessionDisallowDatagrams disallow_datagrams = 4;
inline bool Session::_internal_has_disallow_datagrams() const {
  return Command_case() == kDisallowDatagrams;
}
inline bool Session::has_disallow_datagrams() const {
  return _internal_has_disallow_datagrams();
}
inline void Session::set_has_disallow_datagrams() {
  _oneof_case_[0] = kDisallowDatagrams;
}
inline void Session::clear_disallow_datagrams() {
  if (_internal_has_disallow_datagrams()) {
    if (GetArena() == nullptr) {
      delete Command_.disallow_datagrams_;
    }
    clear_has_Command();
  }
}
inline ::ServerPushInterface::SessionDisallowDatagrams* Session::release_disallow_datagrams() {
  // @@protoc_insertion_point(field_release:ServerPushInterface.Session.disallow_datagrams)
  if (_internal_has_disallow_datagrams()) {
    clear_has_Command();
      ::ServerPushInterface::SessionDisallowDatagrams* temp = Command_.disallow_datagrams_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    Command_.disallow_datagrams_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ServerPushInterface::SessionDisallowDatagrams& Session::_internal_disallow_datagrams() const {
  return _internal_has_disallow_datagrams()
      ? *Command_.disallow_datagrams_
      : *reinterpret_cast< ::ServerPushInterface::SessionDisallowDatagrams*>(&::ServerPushInterface::_SessionDisallowDatagrams_default_instance_);
}
inline const ::ServerPushInterface::SessionDisallowDatagrams& Session::disallow_datagrams() const {
  // @@protoc_insertion_point(field_get:ServerPushInterface.Session.disallow_datagrams)
  return _internal_disallow_datagrams();
}
inline ::ServerPushInterface::SessionDisallowDatagrams* Session::unsafe_arena_release_disallow_datagrams() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ServerPushInterface.Session.disallow_datagrams)
  if (_internal_has_disallow_datagrams()) {
    clear_has_Command();
    ::ServerPushInterface::SessionDisallowDatagrams* temp = Command_.disallow_datagrams_;
    Command_.disallow_datagrams_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Session::unsafe_arena_set_allocated_disallow_datagrams(::ServerPushInterface::SessionDisallowDatagrams* disallow_datagrams) {
  clear_Command();
  if (disallow_datagrams) {
    set_has_disallow_datagrams();
    Command_.disallow_datagrams_ = disallow_datagrams;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ServerPushInterface.Session.disallow_datagrams)
}
inline ::ServerPushInterface::SessionDisallowDatagrams* Session::_internal_mutable_disallow_datagrams() {
  if (!_internal_has_disallow_datagrams()) {
    clear_Command();
    set_has_disallow_datagrams();
    Command_.disallow_datagrams_ = CreateMaybeMessage< ::ServerPushInterface::SessionDisallowDatagrams >(GetArena());
  }
  return Command_.disallow_datagrams_;
}
inline ::ServerPushInterface::SessionDisallowDatagrams* Session::mutable_disallow_datagrams() {
  // @@protoc_insertion_point(field_mutable:ServerPushInterface.Session.disallow_datagrams)
  return _internal_mutable_disallow_datagrams();
}

// .ServerPushInterface.SessionMakeStream make_stream = 5;
inline bool Session::_internal_has_make_stream() const {
  return Command_case() == kMakeStream;
}
inline bool Session::has_make_stream() const {
  return _internal_has_make_stream();
}
inline void Session::set_has_make_stream() {
  _oneof_case_[0] = kMakeStream;
}
inline void Session::clear_make_stream() {
  if (_internal_has_make_stream()) {
    if (GetArena() == nullptr) {
      delete Command_.make_stream_;
    }
    clear_has_Command();
  }
}
inline ::ServerPushInterface::SessionMakeStream* Session::release_make_stream() {
  // @@protoc_insertion_point(field_release:ServerPushInterface.Session.make_stream)
  if (_internal_has_make_stream()) {
    clear_has_Command();
      ::ServerPushInterface::SessionMakeStream* temp = Command_.make_stream_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    Command_.make_stream_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ServerPushInterface::SessionMakeStream& Session::_internal_make_stream() const {
  return _internal_has_make_stream()
      ? *Command_.make_stream_
      : *reinterpret_cast< ::ServerPushInterface::SessionMakeStream*>(&::ServerPushInterface::_SessionMakeStream_default_instance_);
}
inline const ::ServerPushInterface::SessionMakeStream& Session::make_stream() const {
  // @@protoc_insertion_point(field_get:ServerPushInterface.Session.make_stream)
  return _internal_make_stream();
}
inline ::ServerPushInterface::SessionMakeStream* Session::unsafe_arena_release_make_stream() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ServerPushInterface.Session.make_stream)
  if (_internal_has_make_stream()) {
    clear_has_Command();
    ::ServerPushInterface::SessionMakeStream* temp = Command_.make_stream_;
    Command_.make_stream_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Session::unsafe_arena_set_allocated_make_stream(::ServerPushInterface::SessionMakeStream* make_stream) {
  clear_Command();
  if (make_stream) {
    set_has_make_stream();
    Command_.make_stream_ = make_stream;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ServerPushInterface.Session.make_stream)
}
inline ::ServerPushInterface::SessionMakeStream* Session::_internal_mutable_make_stream() {
  if (!_internal_has_make_stream()) {
    clear_Command();
    set_has_make_stream();
    Command_.make_stream_ = CreateMaybeMessage< ::ServerPushInterface::SessionMakeStream >(GetArena());
  }
  return Command_.make_stream_;
}
inline ::ServerPushInterface::SessionMakeStream* Session::mutable_make_stream() {
  // @@protoc_insertion_point(field_mutable:ServerPushInterface.Session.make_stream)
  return _internal_mutable_make_stream();
}

// .ServerPushInterface.SessionFinishStream finish_stream = 6;
inline bool Session::_internal_has_finish_stream() const {
  return Command_case() == kFinishStream;
}
inline bool Session::has_finish_stream() const {
  return _internal_has_finish_stream();
}
inline void Session::set_has_finish_stream() {
  _oneof_case_[0] = kFinishStream;
}
inline void Session::clear_finish_stream() {
  if (_internal_has_finish_stream()) {
    if (GetArena() == nullptr) {
      delete Command_.finish_stream_;
    }
    clear_has_Command();
  }
}
inline ::ServerPushInterface::SessionFinishStream* Session::release_finish_stream() {
  // @@protoc_insertion_point(field_release:ServerPushInterface.Session.finish_stream)
  if (_internal_has_finish_stream()) {
    clear_has_Command();
      ::ServerPushInterface::SessionFinishStream* temp = Command_.finish_stream_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    Command_.finish_stream_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ServerPushInterface::SessionFinishStream& Session::_internal_finish_stream() const {
  return _internal_has_finish_stream()
      ? *Command_.finish_stream_
      : *reinterpret_cast< ::ServerPushInterface::SessionFinishStream*>(&::ServerPushInterface::_SessionFinishStream_default_instance_);
}
inline const ::ServerPushInterface::SessionFinishStream& Session::finish_stream() const {
  // @@protoc_insertion_point(field_get:ServerPushInterface.Session.finish_stream)
  return _internal_finish_stream();
}
inline ::ServerPushInterface::SessionFinishStream* Session::unsafe_arena_release_finish_stream() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ServerPushInterface.Session.finish_stream)
  if (_internal_has_finish_stream()) {
    clear_has_Command();
    ::ServerPushInterface::SessionFinishStream* temp = Command_.finish_stream_;
    Command_.finish_stream_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Session::unsafe_arena_set_allocated_finish_stream(::ServerPushInterface::SessionFinishStream* finish_stream) {
  clear_Command();
  if (finish_stream) {
    set_has_finish_stream();
    Command_.finish_stream_ = finish_stream;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ServerPushInterface.Session.finish_stream)
}
inline ::ServerPushInterface::SessionFinishStream* Session::_internal_mutable_finish_stream() {
  if (!_internal_has_finish_stream()) {
    clear_Command();
    set_has_finish_stream();
    Command_.finish_stream_ = CreateMaybeMessage< ::ServerPushInterface::SessionFinishStream >(GetArena());
  }
  return Command_.finish_stream_;
}
inline ::ServerPushInterface::SessionFinishStream* Session::mutable_finish_stream() {
  // @@protoc_insertion_point(field_mutable:ServerPushInterface.Session.finish_stream)
  return _internal_mutable_finish_stream();
}

// .ServerPushInterface.SessionChangeProperty change_property = 7;
inline bool Session::_internal_has_change_property() const {
  return Command_case() == kChangeProperty;
}
inline bool Session::has_change_property() const {
  return _internal_has_change_property();
}
inline void Session::set_has_change_property() {
  _oneof_case_[0] = kChangeProperty;
}
inline void Session::clear_change_property() {
  if (_internal_has_change_property()) {
    if (GetArena() == nullptr) {
      delete Command_.change_property_;
    }
    clear_has_Command();
  }
}
inline ::ServerPushInterface::SessionChangeProperty* Session::release_change_property() {
  // @@protoc_insertion_point(field_release:ServerPushInterface.Session.change_property)
  if (_internal_has_change_property()) {
    clear_has_Command();
      ::ServerPushInterface::SessionChangeProperty* temp = Command_.change_property_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    Command_.change_property_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ServerPushInterface::SessionChangeProperty& Session::_internal_change_property() const {
  return _internal_has_change_property()
      ? *Command_.change_property_
      : *reinterpret_cast< ::ServerPushInterface::SessionChangeProperty*>(&::ServerPushInterface::_SessionChangeProperty_default_instance_);
}
inline const ::ServerPushInterface::SessionChangeProperty& Session::change_property() const {
  // @@protoc_insertion_point(field_get:ServerPushInterface.Session.change_property)
  return _internal_change_property();
}
inline ::ServerPushInterface::SessionChangeProperty* Session::unsafe_arena_release_change_property() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ServerPushInterface.Session.change_property)
  if (_internal_has_change_property()) {
    clear_has_Command();
    ::ServerPushInterface::SessionChangeProperty* temp = Command_.change_property_;
    Command_.change_property_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Session::unsafe_arena_set_allocated_change_property(::ServerPushInterface::SessionChangeProperty* change_property) {
  clear_Command();
  if (change_property) {
    set_has_change_property();
    Command_.change_property_ = change_property;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ServerPushInterface.Session.change_property)
}
inline ::ServerPushInterface::SessionChangeProperty* Session::_internal_mutable_change_property() {
  if (!_internal_has_change_property()) {
    clear_Command();
    set_has_change_property();
    Command_.change_property_ = CreateMaybeMessage< ::ServerPushInterface::SessionChangeProperty >(GetArena());
  }
  return Command_.change_property_;
}
inline ::ServerPushInterface::SessionChangeProperty* Session::mutable_change_property() {
  // @@protoc_insertion_point(field_mutable:ServerPushInterface.Session.change_property)
  return _internal_mutable_change_property();
}

inline bool Session::has_Command() const {
  return Command_case() != COMMAND_NOT_SET;
}
inline void Session::clear_has_Command() {
  _oneof_case_[0] = COMMAND_NOT_SET;
}
inline Session::CommandCase Session::Command_case() const {
  return Session::CommandCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// SessionAllowDatagrams

// uint32 size = 1;
inline void SessionAllowDatagrams::clear_size() {
  size_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 SessionAllowDatagrams::_internal_size() const {
  return size_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 SessionAllowDatagrams::size() const {
  // @@protoc_insertion_point(field_get:ServerPushInterface.SessionAllowDatagrams.size)
  return _internal_size();
}
inline void SessionAllowDatagrams::_internal_set_size(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  size_ = value;
}
inline void SessionAllowDatagrams::set_size(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_size(value);
  // @@protoc_insertion_point(field_set:ServerPushInterface.SessionAllowDatagrams.size)
}

// -------------------------------------------------------------------

// SessionDisallowDatagrams

// -------------------------------------------------------------------

// SessionFinishStream

// uint32 stream_id = 1;
inline void SessionFinishStream::clear_stream_id() {
  stream_id_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 SessionFinishStream::_internal_stream_id() const {
  return stream_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 SessionFinishStream::stream_id() const {
  // @@protoc_insertion_point(field_get:ServerPushInterface.SessionFinishStream.stream_id)
  return _internal_stream_id();
}
inline void SessionFinishStream::_internal_set_stream_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  stream_id_ = value;
}
inline void SessionFinishStream::set_stream_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_stream_id(value);
  // @@protoc_insertion_point(field_set:ServerPushInterface.SessionFinishStream.stream_id)
}

// -------------------------------------------------------------------

// SessionMakeStream_Response

// uint32 stream_id = 1;
inline void SessionMakeStream_Response::clear_stream_id() {
  stream_id_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 SessionMakeStream_Response::_internal_stream_id() const {
  return stream_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 SessionMakeStream_Response::stream_id() const {
  // @@protoc_insertion_point(field_get:ServerPushInterface.SessionMakeStream.Response.stream_id)
  return _internal_stream_id();
}
inline void SessionMakeStream_Response::_internal_set_stream_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  stream_id_ = value;
}
inline void SessionMakeStream_Response::set_stream_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_stream_id(value);
  // @@protoc_insertion_point(field_set:ServerPushInterface.SessionMakeStream.Response.stream_id)
}

// -------------------------------------------------------------------

// SessionMakeStream

// -------------------------------------------------------------------

// SessionChangeProperty

// uint32 max_rate = 1;
inline bool SessionChangeProperty::_internal_has_max_rate() const {
  return Properties_case() == kMaxRate;
}
inline void SessionChangeProperty::set_has_max_rate() {
  _oneof_case_[0] = kMaxRate;
}
inline void SessionChangeProperty::clear_max_rate() {
  if (_internal_has_max_rate()) {
    Properties_.max_rate_ = 0u;
    clear_has_Properties();
  }
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 SessionChangeProperty::_internal_max_rate() const {
  if (_internal_has_max_rate()) {
    return Properties_.max_rate_;
  }
  return 0u;
}
inline void SessionChangeProperty::_internal_set_max_rate(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  if (!_internal_has_max_rate()) {
    clear_Properties();
    set_has_max_rate();
  }
  Properties_.max_rate_ = value;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 SessionChangeProperty::max_rate() const {
  // @@protoc_insertion_point(field_get:ServerPushInterface.SessionChangeProperty.max_rate)
  return _internal_max_rate();
}
inline void SessionChangeProperty::set_max_rate(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_max_rate(value);
  // @@protoc_insertion_point(field_set:ServerPushInterface.SessionChangeProperty.max_rate)
}

// uint32 max_idle = 2;
inline bool SessionChangeProperty::_internal_has_max_idle() const {
  return Properties_case() == kMaxIdle;
}
inline void SessionChangeProperty::set_has_max_idle() {
  _oneof_case_[0] = kMaxIdle;
}
inline void SessionChangeProperty::clear_max_idle() {
  if (_internal_has_max_idle()) {
    Properties_.max_idle_ = 0u;
    clear_has_Properties();
  }
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 SessionChangeProperty::_internal_max_idle() const {
  if (_internal_has_max_idle()) {
    return Properties_.max_idle_;
  }
  return 0u;
}
inline void SessionChangeProperty::_internal_set_max_idle(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  if (!_internal_has_max_idle()) {
    clear_Properties();
    set_has_max_idle();
  }
  Properties_.max_idle_ = value;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 SessionChangeProperty::max_idle() const {
  // @@protoc_insertion_point(field_get:ServerPushInterface.SessionChangeProperty.max_idle)
  return _internal_max_idle();
}
inline void SessionChangeProperty::set_max_idle(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_max_idle(value);
  // @@protoc_insertion_point(field_set:ServerPushInterface.SessionChangeProperty.max_idle)
}

inline bool SessionChangeProperty::has_Properties() const {
  return Properties_case() != PROPERTIES_NOT_SET;
}
inline void SessionChangeProperty::clear_has_Properties() {
  _oneof_case_[0] = PROPERTIES_NOT_SET;
}
inline SessionChangeProperty::PropertiesCase SessionChangeProperty::Properties_case() const {
  return SessionChangeProperty::PropertiesCase(_oneof_case_[0]);
}
#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace ServerPushInterface

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_Session_2eproto
